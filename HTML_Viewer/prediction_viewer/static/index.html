<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Preprocessed Data Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        header h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }

        header p {
            opacity: 0.9;
            font-size: 16px;
        }

        .directory-section {
            padding: 20px 40px;
            background: #f8f9fa;
            border-bottom: 2px solid #e0e0e0;
        }

        .directory-input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .directory-input-group label {
            font-weight: 600;
            color: #555;
            white-space: nowrap;
        }

        .directory-input-group input {
            flex: 1;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .directory-input-group button {
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            white-space: nowrap;
        }

        .directory-input-group button:hover {
            opacity: 0.9;
        }

        .main-content {
            padding: 30px;
        }

        .stats-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            text-align: center;
        }

        .stats-section h3 {
            margin-bottom: 10px;
            color: #667eea;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-size: 14px;
            font-weight: 600;
            color: #555;
        }

        .control-group select {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            min-width: 200px;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 300px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
            color: #555;
        }

        input[type="range"] {
            width: 100%;
        }

        .viewer-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .viewer-panel {
            border: 2px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            background: #f9f9f9;
        }

        .viewer-header {
            background: #667eea;
            color: white;
            padding: 10px;
            text-align: center;
            font-weight: 600;
            font-size: 13px;
        }

        .viewer-content {
            position: relative;
            width: 100%;
            padding-top: 100%; /* 1:1 aspect ratio */
            background: #000;
        }

        .viewer-content canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            padding: 8px;
            justify-content: center;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-group label {
            cursor: pointer;
            font-size: 14px;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .progress-container {
            display: none;
            max-width: 1200px;
            margin: 10px auto 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #ddd;
        }

        .progress-message {
            font-size: 14px;
            color: #555;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .progress-bar-wrapper {
            width: 100%;
            height: 24px;
            background: #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 10px;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
        }

        .progress-percentage {
            color: white;
            font-size: 12px;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .progress-bar-wrapper::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.3) 50%,
                transparent 100%);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
            display: none;
        }

        .opacity-slider {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            justify-content: center;
        }

        .opacity-slider input[type="range"] {
            width: 120px;
        }

        .opacity-slider span {
            font-size: 14px;
            font-weight: 600;
            color: #555;
            min-width: 35px;
        }

        .legend-container {
            padding: 10px;
            text-align: center;
        }

        .legend-title {
            font-size: 12px;
            font-weight: 600;
            color: #555;
            margin-bottom: 5px;
        }

        .legend-colorbar {
            display: flex;
            height: 20px;
            border: 1px solid #ddd;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 3px;
        }

        .legend-colorbar div {
            flex: 1;
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #666;
        }

        .legend-labels-5 {
            flex-wrap: wrap;
            gap: 3px 5px;
            font-size: 8px;
        }

        .legend-labels-5 span {
            min-width: 20px;
            text-align: center;
        }

        .histogram-container {
            padding: 10px;
            border-top: 1px solid #ddd;
        }

        .histogram-title {
            font-size: 12px;
            font-weight: 600;
            color: #555;
            margin-bottom: 5px;
            text-align: center;
        }

        .histogram-canvas-wrapper {
            position: relative;
            width: 100%;
            height: 120px;
        }

        #histogramCanvas {
            width: 100%;
            height: 100%;
        }

        .histogram-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-top: 8px;
            font-size: 10px;
            color: #666;
        }

        .histogram-stat {
            display: flex;
            justify-content: space-between;
            padding: 2px 5px;
            background: #f8f9fa;
            border-radius: 3px;
        }

        .histogram-stat-label {
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ðŸ”¬ Preprocessed Data Viewer</h1>
            <p>Inspect Aligned T2, Normalized FF, and Segmentation Data</p>
        </header>

        <div class="directory-section">
            <div class="directory-input-group">
                <label for="dirPathInput">Directory:</label>
                <input type="text" id="dirPathInput" placeholder="Enter path to preprocessed_images directory"
                       value="/home/homesOnMaster/dgeiger/repos/Liver_FF_Predictor/datasets/preprocessed_images_fixed3"
                       onkeypress="if(event.key === 'Enter') loadDirectory()">
                <button onclick="loadDirectory()">Load Directory</button>
            </div>
            <div class="error" id="dirError" style="max-width: 1200px; margin: 10px auto 0;"></div>
            <div class="loading" id="dirLoading" style="max-width: 1200px; margin: 10px auto 0;">Loading...</div>
            <div class="progress-container" id="progressContainer">
                <div class="progress-message" id="progressMessage">Initializing...</div>
                <div class="progress-bar-wrapper">
                    <div class="progress-bar" id="progressBar" style="width: 0%">
                        <span class="progress-percentage" id="progressPercentage">0%</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="main-content" id="mainContent">
            <div class="stats-section">
                <h3>ðŸ“‚ Directory Information</h3>
                <p id="statsInfo">Total Patients: 0</p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="filterSelect">Filter:</label>
                    <select id="filterSelect" onchange="onFilterChange()">
                        <option value="all">All Patients</option>
                        <option value="test">Test Set Only (For Inference)</option>
                        <option value="fatty">Fatty Liver Only (â‰¥10%)</option>
                        <option value="normal">Normal Liver Only (<10%)</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="patientSelect">Patient (Dropdown):</label>
                    <select id="patientSelect" onchange="onPatientSelectChange()">
                        <option value="">Select a patient...</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="patientInput">Or Enter Patient ID:</label>
                    <div style="display: flex; gap: 5px;">
                        <input type="text" id="patientInput" placeholder="e.g., 0000016749"
                               onkeypress="if(event.key === 'Enter') loadManualPatient()"
                               style="padding: 8px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px; min-width: 150px;">
                        <button onclick="loadManualPatient()"
                                style="padding: 8px 15px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
                            Load
                        </button>
                    </div>
                </div>

                <div class="slider-container">
                    <div class="slider-label">
                        <span><strong>Slice:</strong></span>
                        <span id="sliceInfo">0 / 0</span>
                        <span id="preloadStatus" style="margin-left: 15px; font-size: 11px; color: #888;"></span>
                    </div>
                    <input type="range" id="sliceSlider" min="0" max="0" value="0"
                           oninput="onSliceInput()" onchange="onSliceChangeComplete()">
                </div>
            </div>

            <div class="viewer-grid">
                <div class="viewer-panel">
                    <div class="viewer-header">T2 Aligned</div>
                    <div class="viewer-content">
                        <canvas id="t2Canvas"></canvas>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showT2Mask" onchange="toggleMask('t2')">
                        <label for="showT2Mask">Show Segmentation</label>
                        <input type="checkbox" id="showErodedMask" onchange="toggleMask('eroded')">
                        <label for="showErodedMask">Show Eroded Mask (3px)</label>
                    </div>
                </div>

                <div class="viewer-panel">
                    <div class="viewer-header">T2 + Fat Fraction Overlay</div>
                    <div class="viewer-content">
                        <canvas id="overlayCanvas"></canvas>
                    </div>
                    <div class="opacity-slider">
                        <label for="overlayOpacity">FF Opacity:</label>
                        <input type="range" id="overlayOpacity" min="0" max="100" value="50"
                               oninput="updateOverlayOpacity()">
                        <span id="opacityValue">50%</span>
                    </div>
                    <div class="opacity-slider">
                        <label style="display:flex;align-items:center;gap:6px;">
                            <input type="checkbox" id="segBoundaryToggle" checked onchange="toggleSegBoundary()">
                            Segmentation boundary
                        </label>
                        <label style="display:flex;align-items:center;gap:6px;">
                            <input type="checkbox" id="erodedBoundaryToggle" onchange="toggleErodedBoundary()">
                            Eroded boundary
                        </label>
                    </div>
                    <div class="legend-container">
                        <div class="legend-title">Fat Fraction (%) - Custom 0.05 Colormap (hue-compressed)</div>
                        <div class="legend-colorbar" id="legendColorbar"></div>
                        <div class="legend-labels legend-labels-5">
                            <span>0%</span>
                            <span>5%</span>
                            <span>10%</span>
                            <span>15%</span>
                            <span>20%</span>
                            <span>25%</span>
                            <span>30%</span>
                            <span>35%</span>
                            <span>40%</span>
                            <span>45%</span>
                            <span>50%</span>
                            <span>55%</span>
                            <span>60%</span>
                            <span>65%</span>
                            <span>70%</span>
                            <span>75%</span>
                            <span>80%</span>
                            <span>85%</span>
                            <span>90%</span>
                            <span>95%</span>
                            <span>100%</span>
                        </div>
                    </div>
                    <div class="histogram-container">
                        <div class="histogram-title">FF Intensity Distribution (Current Slice)</div>
                        <div class="histogram-canvas-wrapper">
                            <canvas id="histogramCanvas"></canvas>
                        </div>
                        <div class="histogram-stats">
                            <div class="histogram-stat">
                                <span class="histogram-stat-label">Min:</span>
                                <span id="histMin">-</span>
                            </div>
                            <div class="histogram-stat">
                                <span class="histogram-stat-label">Max:</span>
                                <span id="histMax">-</span>
                            </div>
                            <div class="histogram-stat">
                                <span class="histogram-stat-label">Mean:</span>
                                <span id="histMean">-</span>
                            </div>
                            <div class="histogram-stat">
                                <span class="histogram-stat-label">Median:</span>
                                <span id="histMedian">-</span>
                            </div>
                            <div class="histogram-stat">
                                <span class="histogram-stat-label">P25:</span>
                                <span id="histP25">-</span>
                            </div>
                            <div class="histogram-stat">
                                <span class="histogram-stat-label">P75:</span>
                                <span id="histP75">-</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="viewer-panel">
                    <div class="viewer-header">Predicted FF (Exp 001)</div>
                    <div class="viewer-content">
                        <canvas id="predCanvas"></canvas>
                    </div>
                    <div class="checkbox-group">
                        <label for="predictionExperiment">Experiment:</label>
                        <select id="predictionExperiment" onchange="onExperimentChange()"></select>
                        <button id="generatePredictionBtn" onclick="generatePrediction()" style="padding: 8px 12px; background: #34a853; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Run Prediction</button>
                        <input type="checkbox" id="showPred" onchange="togglePrediction()">
                        <label for="showPred">Show Prediction</label>
                    </div>
                    <div class="legend-container">
                        <div class="legend-title">Fat Fraction (%) - Custom 0.05 Colormap (hue-compressed)</div>
                        <div class="legend-colorbar" id="legendColorbarPred"></div>
                        <div class="legend-labels legend-labels-5">
                            <span>0%</span>
                            <span>5%</span>
                            <span>10%</span>
                            <span>15%</span>
                            <span>20%</span>
                            <span>25%</span>
                            <span>30%</span>
                            <span>35%</span>
                            <span>40%</span>
                            <span>45%</span>
                            <span>50%</span>
                            <span>55%</span>
                            <span>60%</span>
                            <span>65%</span>
                            <span>70%</span>
                            <span>75%</span>
                            <span>80%</span>
                            <span>85%</span>
                            <span>90%</span>
                            <span>95%</span>
                            <span>100%</span>
                        </div>
                    </div>
                    <div class="histogram-container">
                        <div class="histogram-title">Predicted FF Distribution (Current Slice)</div>
                        <div class="histogram-canvas-wrapper">
                            <canvas id="histogramCanvasPred"></canvas>
                        </div>
                        <div class="histogram-stats">
                            <div class="histogram-stat">
                                <span class="histogram-stat-label">Min:</span>
                                <span id="histMinPred">-</span>
                            </div>
                            <div class="histogram-stat">
                                <span class="histogram-stat-label">Max:</span>
                                <span id="histMaxPred">-</span>
                            </div>
                            <div class="histogram-stat">
                                <span class="histogram-stat-label">Mean:</span>
                                <span id="histMeanPred">-</span>
                            </div>
                            <div class="histogram-stat">
                                <span class="histogram-stat-label">Median:</span>
                                <span id="histMedianPred">-</span>
                            </div>
                            <div class="histogram-stat">
                                <span class="histogram-stat-label">P25:</span>
                                <span id="histP25Pred">-</span>
                            </div>
                            <div class="histogram-stat">
                                <span class="histogram-stat-label">P75:</span>
                                <span id="histP75Pred">-</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = window.location.origin;
        const COLORMAP_VERSION = 'distinct_0p05_hc1.0';
        let currentPatientId = null;
        let currentSlice = 0;
        let numSlices = 0;
        let patientsData = [];
        let allPatientsData = [];  // Store all patients before filtering
        let currentFilter = 'all';
        let currentExperiment = null;
        let predictionAvailable = false;
        let preloadToken = 0;
        let predictionCacheBust = 0;

        let showSegBoundary = true;
        let showErodedBoundary = false;

        // Image caches
        const imageCache = {
            t2: {},
            ff: {},
            seg: {},
            seg_eroded: {},
            pred: {}
        };
        const histogramCache = {
            ff: {},
            pred: {}
        };

        // Boundary cache for segmentation boundaries
        const boundaryCache = {};

        // Mask visibility state
        const maskVisible = {
            t2: false,
            ff: false,
            eroded: false
        };

        // Prediction display state
        let showPrediction = false;
        let predictionPolling = null;

        // Overlay opacity (0-100)
        let overlayOpacity = 50;

        // Custom colormap (matches backend FF/prediction rendering)
        const CUSTOM_COLORMAP_VALUES = [
            0.00, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45,
            0.50, 0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95, 1.00
        ];
        const CUSTOM_COLORMAP_COLORS = [
            '#00008B', '#00008B', '#0000FF', '#00CED1', '#008000',
            '#7CFC00', '#FFFF00', '#FFD700', '#FFA500', '#F28C28',
            '#E8742A', '#DE5B2A', '#D44227', '#C92A22', '#B71B1B',
            '#A51214', '#930A0D', '#8B0000', '#7A0000', '#6A0000', '#5A0000'
        ];

        function hexToRgb(hex) {
            const value = hex.replace('#', '');
            const r = parseInt(value.slice(0, 2), 16);
            const g = parseInt(value.slice(2, 4), 16);
            const b = parseInt(value.slice(4, 6), 16);
            return [r, g, b];
        }

        function getCustomColor(value) {
            const v = Math.max(0, Math.min(1, value));
            for (let i = 0; i < CUSTOM_COLORMAP_VALUES.length - 1; i++) {
                const v0 = CUSTOM_COLORMAP_VALUES[i];
                const v1 = CUSTOM_COLORMAP_VALUES[i + 1];
                if (v >= v0 && v <= v1) {
                    const t = v1 === v0 ? 0 : (v - v0) / (v1 - v0);
                    const [r0, g0, b0] = hexToRgb(CUSTOM_COLORMAP_COLORS[i]);
                    const [r1, g1, b1] = hexToRgb(CUSTOM_COLORMAP_COLORS[i + 1]);
                    return [
                        Math.round(r0 + (r1 - r0) * t),
                        Math.round(g0 + (g1 - g0) * t),
                        Math.round(b0 + (b1 - b0) * t)
                    ];
                }
            }
            return hexToRgb(CUSTOM_COLORMAP_COLORS[CUSTOM_COLORMAP_COLORS.length - 1]);
        }

        function hsvToRgb(h, s, v) {
            const c = v * s;
            const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
            const m = v - c;
            let r = 0;
            let g = 0;
            let b = 0;

            if (h >= 0 && h < 60) {
                r = c; g = x; b = 0;
            } else if (h >= 60 && h < 120) {
                r = x; g = c; b = 0;
            } else if (h >= 120 && h < 180) {
                r = 0; g = c; b = x;
            } else if (h >= 180 && h < 240) {
                r = 0; g = x; b = c;
            } else if (h >= 240 && h < 300) {
                r = x; g = 0; b = c;
            } else {
                r = c; g = 0; b = x;
            }

            return [
                Math.round((r + m) * 255),
                Math.round((g + m) * 255),
                Math.round((b + m) * 255)
            ];
        }

        function getRainbowColor(value) {
            const v = Math.max(0, Math.min(1, value));
            const hue = (1 - v) * 240; // blue -> red
            return hsvToRgb(hue, 1, 1);
        }

        // Apply colormap to grayscale image
        function applyColormap(imageData) {
            const data = imageData.data;
            const newData = new Uint8ClampedArray(data.length);

            for (let i = 0; i < data.length; i += 4) {
                const gray = data[i];
                const value = gray / 255.0;

                const [r, g, b] = getCustomColor(value);

                newData[i] = r;
                newData[i + 1] = g;
                newData[i + 2] = b;
                newData[i + 3] = 255;
            }

            const colored = new ImageData(newData, imageData.width, imageData.height);
            return colored;
        }

        // Render image to canvas with optional colormap and mask overlay
        function renderToCanvas(canvasId, img, maskImg, useMask, useColormap) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');

            canvas.width = img.width;
            canvas.height = img.height;

            ctx.drawImage(img, 0, 0);

            if (useColormap) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const colored = applyColormap(imageData);
                ctx.putImageData(colored, 0, 0);
            }

            if (useMask && maskImg) {
                ctx.globalAlpha = 0.5;
                ctx.drawImage(maskImg, 0, 0);
                ctx.globalAlpha = 1.0;
            }
        }

        function drawMaskOverlay(canvasId, maskImg, alpha = 0.5) {
            if (!maskImg) return;
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            ctx.globalAlpha = alpha;
            ctx.drawImage(maskImg, 0, 0);
            ctx.globalAlpha = 1.0;
        }

        // Render segmentation mask as colored overlay
        function renderSegmentationCanvas(canvasId, maskImg) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');

            canvas.width = maskImg.width;
            canvas.height = maskImg.height;

            // Fill with black background
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw mask
            ctx.drawImage(maskImg, 0, 0);
        }

        // Extract boundary from segmentation mask
        function extractSegmentationBoundary(segImg, patientId, sliceIdx) {
            if (!segImg) {
                console.log('[BOUNDARY] No segmentation image provided');
                return null;
            }

            // Check cache first
            const boundaryCacheKey = `${patientId}_${sliceIdx}_${segImg.__boundaryKey || "seg"}`;
            if (boundaryCache[boundaryCacheKey]) {
                console.log('[BOUNDARY] Using cached boundary');
                return boundaryCache[boundaryCacheKey];
            }

            console.log('[BOUNDARY] Extracting boundary from segmentation mask:', segImg.width, 'x', segImg.height);

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = segImg.width;
            tempCanvas.height = segImg.height;
            tempCtx.drawImage(segImg, 0, 0);

            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;
            const width = tempCanvas.width;
            const height = tempCanvas.height;

            // Create boundary canvas
            const boundaryCanvas = document.createElement('canvas');
            boundaryCanvas.width = width;
            boundaryCanvas.height = height;
            const boundaryCtx = boundaryCanvas.getContext('2d');
            const boundaryData = boundaryCtx.createImageData(width, height);

            let boundaryPixelCount = 0;
            let maskPixelCount = 0;

            const boundaryRadius = 1;

            function paintBoundaryPixel(px, py) {
                if (px < 0 || py < 0 || px >= width || py >= height) {
                    return;
                }
                const pIdx = (py * width + px) * 4;
                boundaryData.data[pIdx] = 139;
                boundaryData.data[pIdx + 1] = 0;
                boundaryData.data[pIdx + 2] = 0;
                boundaryData.data[pIdx + 3] = 255;
            }

            // Detect edges (any non-black pixel with a black neighbor is a boundary)
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];

                    // Check if current pixel is part of the mask (non-black)
                    if (r > 10 || g > 10 || b > 10) {
                        maskPixelCount++;
                        // Check 4 neighbors (up, down, left, right)
                        let isBoundary = false;

                        // Check left
                        if (x > 0) {
                            const leftIdx = (y * width + (x - 1)) * 4;
                            if (data[leftIdx] <= 10 && data[leftIdx + 1] <= 10 && data[leftIdx + 2] <= 10) {
                                isBoundary = true;
                            }
                        } else {
                            isBoundary = true; // Edge of image
                        }
                        // Check right
                        if (x < width - 1) {
                            const rightIdx = (y * width + (x + 1)) * 4;
                            if (data[rightIdx] <= 10 && data[rightIdx + 1] <= 10 && data[rightIdx + 2] <= 10) {
                                isBoundary = true;
                            }
                        } else {
                            isBoundary = true; // Edge of image
                        }
                        // Check up
                        if (y > 0) {
                            const upIdx = ((y - 1) * width + x) * 4;
                            if (data[upIdx] <= 10 && data[upIdx + 1] <= 10 && data[upIdx + 2] <= 10) {
                                isBoundary = true;
                            }
                        } else {
                            isBoundary = true; // Edge of image
                        }
                        // Check down
                        if (y < height - 1) {
                            const downIdx = ((y + 1) * width + x) * 4;
                            if (data[downIdx] <= 10 && data[downIdx + 1] <= 10 && data[downIdx + 2] <= 10) {
                                isBoundary = true;
                            }
                        } else {
                            isBoundary = true; // Edge of image
                        }

                        if (isBoundary) {
                            for (let dy = -boundaryRadius; dy <= boundaryRadius; dy++) {
                                for (let dx = -boundaryRadius; dx <= boundaryRadius; dx++) {
                                    paintBoundaryPixel(x + dx, y + dy);
                                }
                            }
                            boundaryPixelCount++;
                        }
                    }
                }
            }

            console.log('[BOUNDARY] Mask pixels:', maskPixelCount, 'Boundary pixels:', boundaryPixelCount);

            boundaryCtx.putImageData(boundaryData, 0, 0);

            // Cache the boundary for future use (reuse boundaryCacheKey from above)
            boundaryCache[boundaryCacheKey] = boundaryCanvas;

            return boundaryCanvas;
        }

        // Render T2 with Fat Fraction overlay (FF is already colored by backend)
        function renderOverlayCanvasPrecolored(canvasId, t2Img, ffImg, opacity, segImg = null, erodedImg = null, patientId = null, sliceIdx = null) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');

            canvas.width = t2Img.width;
            canvas.height = t2Img.height;

            // Draw T2 as grayscale base
            ctx.drawImage(t2Img, 0, 0);

            // Draw pre-colored FF at specified opacity
            ctx.globalAlpha = opacity / 100.0;
            ctx.drawImage(ffImg, 0, 0);
            ctx.globalAlpha = 1.0;

            // Draw segmentation boundary if enabled
            if (segImg && showSegBoundary) {
                segImg.__boundaryKey = 'seg';
                const boundaryCanvas = extractSegmentationBoundary(segImg, patientId, sliceIdx);
                if (boundaryCanvas) {
                    ctx.filter = 'blur(1px)';
                    ctx.drawImage(boundaryCanvas, 0, 0);
                    ctx.filter = 'none';
                }
            }

            // Draw eroded segmentation boundary if enabled
            if (erodedImg && showErodedBoundary) {
                erodedImg.__boundaryKey = 'eroded';
                const boundaryCanvas = extractSegmentationBoundary(erodedImg, patientId, sliceIdx);
                if (boundaryCanvas) {
                    ctx.filter = 'blur(1px)';
                    ctx.drawImage(boundaryCanvas, 0, 0);
                    ctx.filter = 'none';
                }
            }
        }

        function renderPredictionOverlay(canvasId, t2Img, predImg, segImg, t2Opacity) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');

            canvas.width = t2Img.width;
            canvas.height = t2Img.height;

            ctx.globalAlpha = t2Opacity;
            ctx.drawImage(t2Img, 0, 0);
            ctx.globalAlpha = 1.0;

            if (!segImg) {
                ctx.drawImage(predImg, 0, 0);
                return;
            }

            const maskCanvas = document.createElement('canvas');
            const maskCtx = maskCanvas.getContext('2d');
            maskCanvas.width = segImg.width;
            maskCanvas.height = segImg.height;
            maskCtx.drawImage(segImg, 0, 0);

            const maskData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
            const data = maskData.data;
            for (let i = 0; i < data.length; i += 4) {
                const hasMask = data[i] > 0 || data[i + 1] > 0 || data[i + 2] > 0;
                data[i] = 0;
                data[i + 1] = 0;
                data[i + 2] = 0;
                data[i + 3] = hasMask ? 255 : 0;
            }
            maskCtx.putImageData(maskData, 0, 0);

            const blurRadius = 5;
            const softMaskCanvas = document.createElement('canvas');
            const softMaskCtx = softMaskCanvas.getContext('2d');
            softMaskCanvas.width = maskCanvas.width;
            softMaskCanvas.height = maskCanvas.height;
            softMaskCtx.filter = `blur(${blurRadius}px)`;
            softMaskCtx.drawImage(maskCanvas, 0, 0);
            softMaskCtx.filter = 'none';

            const predCanvas = document.createElement('canvas');
            const predCtx = predCanvas.getContext('2d');
            predCanvas.width = predImg.width;
            predCanvas.height = predImg.height;
            predCtx.drawImage(predImg, 0, 0);
            predCtx.globalCompositeOperation = 'destination-in';
            predCtx.drawImage(softMaskCanvas, 0, 0);

            ctx.drawImage(predCanvas, 0, 0);
        }

        // Update overlay opacity from slider
        function toggleSegBoundary() {
            showSegBoundary = document.getElementById('segBoundaryToggle').checked;
            boundaryCache[`${currentPatientId}_${currentSlice}_seg`] = null;
            updateImages();
        }

        function toggleErodedBoundary() {
            showErodedBoundary = document.getElementById('erodedBoundaryToggle').checked;
            boundaryCache[`${currentPatientId}_${currentSlice}_eroded`] = null;
            updateImages();
        }

        function updateOverlayOpacity() {
            overlayOpacity = parseInt(document.getElementById('overlayOpacity').value);
            document.getElementById('opacityValue').textContent = `${overlayOpacity}%`;
            updateImages();
        }

        // Compute statistics from array
        function computeStats(values) {
            const sorted = values.slice().sort((a, b) => a - b);
            const n = sorted.length;

            const min = sorted[0];
            const max = sorted[n - 1];
            const mean = values.reduce((a, b) => a + b, 0) / n;
            const median = n % 2 === 0
                ? (sorted[Math.floor(n / 2) - 1] + sorted[Math.floor(n / 2)]) / 2
                : sorted[Math.floor(n / 2)];
            const p25 = sorted[Math.floor(n * 0.25)];
            const p75 = sorted[Math.floor(n * 0.75)];

            return { min, max, mean, median, p25, p75 };
        }

        // Render histogram from Fat Fraction image (RGB colored by backend)
        function renderHistogram(ffImg) {
            // Extract pixel values from FF image
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = ffImg.width;
            tempCanvas.height = ffImg.height;
            tempCtx.drawImage(ffImg, 0, 0);

            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;

            // Convert RGB back to grayscale values using inverse Jet colormap approximation
            // Since FF is colored by Jet, we can use the red channel as a rough estimate
            // or better yet, convert RGB back to intensity
            const values = [];
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i] / 255.0;
                const g = data[i + 1] / 255.0;
                const b = data[i + 2] / 255.0;

                // Inverse colormap approximation (kept for compatibility)
                // Blue (0,0,1) -> 0.0, Cyan (0,1,1) -> 0.25, Green (0,1,0) -> 0.5, Yellow (1,1,0) -> 0.75, Red (1,0,0) -> 1.0
                let value;
                if (b > 0.9 && r < 0.1 && g < 0.5) {
                    // Blue region (0-0.25)
                    value = g * 0.25;
                } else if (b > 0.5 && g > 0.9 && r < 0.1) {
                    // Cyan region (0.25-0.5)
                    value = 0.25 + (1.0 - b) * 0.25;
                } else if (g > 0.9 && b < 0.1 && r < 0.9) {
                    // Green region (0.5-0.75)
                    value = 0.5 + r * 0.25;
                } else if (r > 0.9 && b < 0.1) {
                    // Yellow-Red region (0.75-1.0)
                    value = 0.75 + (1.0 - g) * 0.25;
                } else {
                    // Fallback: use average of RGB
                    value = (r + g + b) / 3.0;
                }

                values.push(value);
            }

            // Compute statistics
            const stats = computeStats(values);

            // Update stats display
            document.getElementById('histMin').textContent = (stats.min * 100).toFixed(2) + '%';
            document.getElementById('histMax').textContent = (stats.max * 100).toFixed(2) + '%';
            document.getElementById('histMean').textContent = (stats.mean * 100).toFixed(2) + '%';
            document.getElementById('histMedian').textContent = (stats.median * 100).toFixed(2) + '%';
            document.getElementById('histP25').textContent = (stats.p25 * 100).toFixed(2) + '%';
            document.getElementById('histP75').textContent = (stats.p75 * 100).toFixed(2) + '%';

            // Create histogram bins
            const numBins = 50;
            const bins = new Array(numBins).fill(0);

            values.forEach(v => {
                const binIdx = Math.min(Math.floor(v * numBins), numBins - 1);
                bins[binIdx]++;
            });

            // Render histogram
            const canvas = document.getElementById('histogramCanvas');
            const ctx = canvas.getContext('2d');

            // Set canvas size
            canvas.width = canvas.offsetWidth * window.devicePixelRatio;
            canvas.height = canvas.offsetHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;
            const padding = { top: 10, right: 10, bottom: 30, left: 40 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            // Clear canvas
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, width, height);

            // Find max bin value for scaling
            const maxBin = Math.max(...bins);

            // Draw bars
            const barWidth = chartWidth / numBins;
            bins.forEach((count, i) => {
                const barHeight = (count / maxBin) * chartHeight;
                const x = padding.left + i * barWidth;
                const y = padding.top + chartHeight - barHeight;

                // Color bar by rainbow colormap
                const value = i / (numBins - 1);
                const [r, g, b] = getCustomColor(value);
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fillRect(x, y, Math.max(barWidth - 1, 1), barHeight);
            });

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, padding.top + chartHeight);
            ctx.lineTo(padding.left + chartWidth, padding.top + chartHeight);
            ctx.stroke();

            // Draw x-axis labels
            ctx.fillStyle = '#666';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';

            const xLabels = [0, 0.25, 0.5, 0.75, 1.0];
            xLabels.forEach(val => {
                const x = padding.left + val * chartWidth;
                const y = padding.top + chartHeight + 15;
                ctx.fillText((val * 100).toFixed(0) + '%', x, y);
            });

            // Draw y-axis label
            ctx.save();
            ctx.translate(15, padding.top + chartHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('Count', 0, 0);
            ctx.restore();
        }

        // Generate colorbar legend
        function generateColorbarLegend() {
            // Generate for T2+FF overlay panel
            const colorbar = document.getElementById('legendColorbar');
            colorbar.innerHTML = '';
            colorbar.style.backgroundImage = `url(${API_BASE}/api/legend/rainbow?width=512&height=16&ts=${Date.now()})`;
            colorbar.style.backgroundSize = '100% 100%';

            // Generate for prediction panel
            const colorbarPred = document.getElementById('legendColorbarPred');
            colorbarPred.innerHTML = '';
            colorbarPred.style.backgroundImage = `url(${API_BASE}/api/legend/rainbow?width=512&height=16&ts=${Date.now()})`;
            colorbarPred.style.backgroundSize = '100% 100%';
        }

        // Update stats display based on current filter
        function updateStatsDisplay() {
            const fattyCount = allPatientsData.filter(p => p.has_fatty_liver === true).length;
            const normalCount = allPatientsData.filter(p => p.has_fatty_liver === false).length;
            const unknownCount = allPatientsData.filter(p => p.has_fatty_liver === null).length;
            const testCount = allPatientsData.filter(p => p.data_split === 'test').length;
            const trainCount = allPatientsData.filter(p => p.data_split === 'train').length;
            const valCount = allPatientsData.filter(p => p.data_split === 'val').length;

            let statsText = `Total: ${allPatientsData.length} patients`;
            if (currentFilter === 'test') {
                statsText = `Test Set: ${testCount} patients (for inference)`;
            } else if (currentFilter === 'fatty') {
                statsText = `Fatty Liver: ${fattyCount} patients (â‰¥10% mean FF)`;
            } else if (currentFilter === 'normal') {
                statsText = `Normal Liver: ${normalCount} patients (<10% mean FF)`;
            } else {
                statsText += ` (Train: ${trainCount}, Val: ${valCount}, Test: ${testCount}`;
                if (fattyCount > 0 || normalCount > 0) {
                    statsText += ` | Fatty: ${fattyCount}, Normal: ${normalCount}`;
                }
                if (unknownCount > 0) {
                    statsText += `, Unknown: ${unknownCount}`;
                }
                statsText += ')';
            }

            document.getElementById('statsInfo').textContent = statsText;
        }

        // Populate patient dropdown with current filtered list
        function populatePatientDropdown(patients) {
            const select = document.getElementById('patientSelect');
            select.innerHTML = '<option value="">Select a patient...</option>';

            patients.forEach(patient => {
                const option = document.createElement('option');
                option.value = patient.patient_id;

                // Build display text
                let displayText = `${patient.patient_id} (${patient.num_slices} slices`;

                // Add data split if not showing test filter (to avoid redundancy)
                if (currentFilter !== 'test' && patient.data_split && patient.data_split !== 'unknown') {
                    displayText += `, ${patient.data_split.toUpperCase()}`;
                }

                if (patient.mean_ff_percent !== undefined) {
                    displayText += `, FF: ${patient.mean_ff_percent.toFixed(1)}%`;
                }
                displayText += ')';

                option.textContent = displayText;
                select.appendChild(option);
            });
        }

        // Handle filter change
        function onFilterChange() {
            currentFilter = document.getElementById('filterSelect').value;

            // Filter patients
            if (currentFilter === 'test') {
                patientsData = allPatientsData.filter(p => p.data_split === 'test');
            } else if (currentFilter === 'fatty') {
                patientsData = allPatientsData.filter(p => p.has_fatty_liver === true);
            } else if (currentFilter === 'normal') {
                patientsData = allPatientsData.filter(p => p.has_fatty_liver === false);
            } else {
                patientsData = allPatientsData;
            }

            // Update display
            updateStatsDisplay();
            populatePatientDropdown(patientsData);

            // Clear current selection
            document.getElementById('patientSelect').value = '';
            document.getElementById('patientInput').value = '';

            // Load first patient if available
            if (patientsData.length > 0) {
                document.getElementById('patientSelect').value = patientsData[0].patient_id;
                loadPatient(patientsData[0].patient_id);
            }
        }

        function updateProgress(message, progress) {
            document.getElementById('progressMessage').textContent = message;
            document.getElementById('progressBar').style.width = `${progress}%`;
            document.getElementById('progressPercentage').textContent = `${progress}%`;
        }

        async function loadExperiments() {
            try {
                const response = await fetch(`${API_BASE}/api/prediction/experiments`);
                if (!response.ok) {
                    return;
                }
                const data = await response.json();
                const experiments = data.experiments || [];
                const select = document.getElementById('predictionExperiment');
                select.innerHTML = '';

                experiments.forEach(exp => {
                    const option = document.createElement('option');
                    option.value = exp.name;
                    option.textContent = exp.name;
                    select.appendChild(option);
                });

                if (experiments.length > 0) {
                    const defaultExp = data.default_experiment || experiments[0].name;
                    select.value = defaultExp;
                    currentExperiment = defaultExp;
                    updatePredictionButtonLabel();
                    await onExperimentChange();
                }
            } catch (err) {
                console.warn('Failed to load experiments:', err);
            }
        }

        function getSelectedExperiment() {
            const select = document.getElementById('predictionExperiment');
            return select && select.value ? select.value : null;
        }

        function updatePredictionButtonLabel() {
            const button = document.getElementById('generatePredictionBtn');
            if (!button) return;
            const exp = getSelectedExperiment();
            button.textContent = exp ? `Run Prediction (${exp})` : 'Run Prediction';
        }

        async function onExperimentChange() {
            currentExperiment = getSelectedExperiment();
            updatePredictionButtonLabel();
            await updateSplitForExperiment();
            await refreshPredictionAvailability();
            imageCache.pred = {};
            histogramCache.pred = {};
            predictionCacheBust += 1;
            updateImages();
            updateHistogram();
            if (currentPatientId) {
                loadPatient(currentPatientId);
            }
        }


        async function updateSplitForExperiment() {
            const exp = getSelectedExperiment();
            try {
                const resp = await fetch(`${API_BASE}/api/prediction/splits`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ experiment: exp })
                });
                if (!resp.ok) {
                    const data = await resp.json().catch(() => ({}));
                    console.warn('Failed to update splits for experiment:', data.error || resp.statusText);
                }
            } catch (err) {
                console.warn('Failed to update splits for experiment:', err);
            }

            try {
                const resp = await fetch(`${API_BASE}/api/patients`);
                if (resp.ok) {
                    const data = await resp.json();
                    allPatientsData = data.patients || [];
                    patientsData = allPatientsData;
                    onFilterChange();
                }
            } catch (err) {
                console.warn('Failed to refresh patients after split change:', err);
            }
        }

        async function refreshPredictionAvailability() {
            if (!currentPatientId) {
                predictionAvailable = false;
                return;
            }

            const exp = getSelectedExperiment();
            const url = `${API_BASE}/api/prediction/available?patient_id=${encodeURIComponent(currentPatientId)}&experiment=${encodeURIComponent(exp || '')}`;
            try {
                const resp = await fetch(url);
                if (!resp.ok) {
                    predictionAvailable = false;
                } else {
                    const data = await resp.json();
                    predictionAvailable = !!data.available;
                }
            } catch (err) {
                predictionAvailable = false;
            }

            try {
                const checkbox = document.getElementById('showPred');
                checkbox.checked = predictionAvailable;
                showPrediction = predictionAvailable;
            } catch (e) {
                // ignore
            }
        }

        async function loadDirectory() {
            const dirPath = document.getElementById('dirPathInput').value.trim();
            if (!dirPath) {
                showError('dirError', 'Please enter a directory path');
                return;
            }

            document.getElementById('dirLoading').style.display = 'none';
            document.getElementById('dirError').style.display = 'none';
            document.getElementById('progressContainer').style.display = 'block';
            updateProgress('Starting...', 0);

            // Start listening to progress updates
            const eventSource = new EventSource(`${API_BASE}/api/initialize/progress?dir=${encodeURIComponent(dirPath)}`);

            eventSource.onmessage = function(event) {
                const data = JSON.parse(event.data);

                if (data.error) {
                    showError('dirError', data.error);
                    document.getElementById('progressContainer').style.display = 'none';
                    eventSource.close();
                    return;
                }

                updateProgress(data.message, data.progress);

                if (data.stage === 'complete' || data.stage === 'timeout') {
                    eventSource.close();
                    // Small delay before loading
                    setTimeout(() => {
                        loadDirectoryData(dirPath);
                    }, 500);
                }
            };

            eventSource.onerror = function(error) {
                console.error('EventSource error:', error);
                eventSource.close();
                // Continue with loading anyway
                loadDirectoryData(dirPath);
            };
        }

        async function loadDirectoryData(dirPath) {
            try {
                updateProgress('Loading patient data...', 95);

                const response = await fetch(`${API_BASE}/api/initialize`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ preprocessed_dir: dirPath })
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'Failed to load directory');
                }

                updateProgress('Complete!', 100);

                allPatientsData = data.patients;
                patientsData = data.patients;

                // Update stats
                updateStatsDisplay();

                // Populate patient dropdown
                populatePatientDropdown(patientsData);

                // Generate colorbar legend
                generateColorbarLegend();
                await loadExperiments();
                await refreshPredictionAvailability();

                // Clear any previous patient selection
                currentPatientId = null;
                currentSlice = 0;
                document.getElementById('patientInput').value = '';

                // Hide progress bar after a short delay
                setTimeout(() => {
                    document.getElementById('progressContainer').style.display = 'none';
                }, 1000);

                // Preload first patient if available
                if (patientsData.length > 0) {
                    const select = document.getElementById('patientSelect');
                    select.value = patientsData[0].patient_id;
                    loadPatient(patientsData[0].patient_id);
                }

            } catch (error) {
                showError('dirError', error.message);
                document.getElementById('progressContainer').style.display = 'none';
            }
        }

        function onPatientSelectChange() {
            const patientId = document.getElementById('patientSelect').value;
            if (!patientId) return;

            // Clear manual input
            document.getElementById('patientInput').value = '';

            // Load the patient
            loadPatient(patientId);
        }

        function loadManualPatient() {
            const patientId = document.getElementById('patientInput').value.trim();
            if (!patientId) {
                alert('Please enter a patient ID');
                return;
            }

            // Clear dropdown selection
            document.getElementById('patientSelect').value = '';

            // Load the patient
            loadPatient(patientId);
        }

        async function loadPatient(patientId) {
            currentPatientId = patientId;
            preloadToken += 1;
            const localPreloadToken = preloadToken;

            // Try to find patient in all loaded data (not just filtered)
            const patient = allPatientsData.find(p => p.patient_id === patientId);

            if (!patient) {
                alert(`Patient ${patientId} not found in the loaded directory`);
                return;
            }

            numSlices = patient.num_slices;

            await refreshPredictionAvailability();

            // Update slider
            const slider = document.getElementById('sliceSlider');
            slider.max = numSlices - 1;
            slider.value = 0;
            currentSlice = 0;

            updateSliceInfo();

            // Clear image caches
            imageCache.t2 = {};
            imageCache.ff = {};
            imageCache.seg = {};
            imageCache.seg_eroded = {};
            imageCache.pred = {};
            histogramCache.ff = {};
            histogramCache.pred = {};

            // Clear boundary cache (boundaries are patient-specific)
            Object.keys(boundaryCache).forEach(key => {
                if (key.startsWith(`${currentPatientId}_`)) {
                    delete boundaryCache[key];
                }
            });

            // Display current slice immediately
            updateImages();

            // Preload all slices in the background (non-blocking)
            setTimeout(() => {
                preloadAllSlices(localPreloadToken);
                preloadAllHistograms(localPreloadToken);
            }, 100);
        }

        // Called on every slider movement (oninput) - fast, no network requests
        function onSliceInput() {
            currentSlice = parseInt(document.getElementById('sliceSlider').value);
            updateSliceInfo();
            updateImages();
            updateHistogram();
        }

        // Called when slider is released (onchange) - ensure histograms are updated
        function onSliceChangeComplete() {
            currentSlice = parseInt(document.getElementById('sliceSlider').value);
            updateSliceInfo();
            updateImages();
            updateHistogram();
            // No need to preload - all slices are preloaded when patient is loaded
        }

        // Legacy function for compatibility
        function onSliceChange() {
            onSliceChangeComplete();
        }

        function updateSliceInfo() {
            document.getElementById('sliceInfo').textContent = `${currentSlice + 1} / ${numSlices}`;
        }

        async function updateImages() {
            if (!currentPatientId) return;

            const patientId = currentPatientId;
            const sliceIdx = currentSlice;

            const t2Loaded = await loadImage('t2', patientId, sliceIdx);
            const ffLoaded = await loadImage('ff', patientId, sliceIdx);
            const segLoaded = await loadImage('seg', patientId, sliceIdx);
            const erodedLoaded = (maskVisible.eroded || showErodedBoundary)
                ? await loadImage('seg_eroded', patientId, sliceIdx)
                : Promise.resolve(null);

            // Try to load prediction image; it's optional and may not exist yet
            let predImg = null;
            if (predictionAvailable) {
                try {
                    predImg = await loadImage('pred', patientId, sliceIdx);
                } catch (err) {
                    predImg = null;
                }
            }

            Promise.all([t2Loaded, ffLoaded, segLoaded, erodedLoaded]).then(([t2Img, ffImg, segImg, erodedImg]) => {
                // Render T2 (grayscale, optional mask)
                renderToCanvas('t2Canvas', t2Img, segImg, maskVisible.t2, false);
                if (maskVisible.eroded && erodedImg) {
                    drawMaskOverlay('t2Canvas', erodedImg, 0.5);
                }

                // Render T2 + FF overlay (FF is already colored) with segmentation boundary
                renderOverlayCanvasPrecolored('overlayCanvas', t2Img, ffImg, overlayOpacity, segImg, erodedImg, patientId, sliceIdx);

                // Render prediction if available
                if (predImg) {
                    console.log('[FRONTEND] Rendering prediction image', predImg.width, 'x', predImg.height);
                    renderPredictionOverlay('predCanvas', t2Img, predImg, segImg, 0.3);
                } else {
                    console.log('[FRONTEND] No prediction image available, showing placeholder');
                    // Show placeholder if no prediction available
                    const canvas = document.getElementById('predCanvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = t2Img.width;
                    canvas.height = t2Img.height;
                    ctx.fillStyle = '#2a2a2a';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#888';
                    ctx.font = '16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('No Prediction Available', canvas.width / 2, canvas.height / 2);
                    ctx.font = '12px sans-serif';
                    ctx.fillText('Click "Run Prediction" to generate', canvas.width / 2, canvas.height / 2 + 20);
                }
            });
        }

        async function loadImage(type, patientId, sliceIdx) {
            const cacheKey = type === 'ff'
                ? `${patientId}_${sliceIdx}_${COLORMAP_VERSION}`
                : type === 'pred'
                    ? `${patientId}_${sliceIdx}_${COLORMAP_VERSION}_${currentExperiment || 'default'}`
                    : type === 'seg_eroded'
                        ? `${patientId}_${sliceIdx}_eroded_${COLORMAP_VERSION}`
                        : `${patientId}_${sliceIdx}`;

            if (imageCache[type][cacheKey]) {
                return imageCache[type][cacheKey];
            }

            let endpoint;
            switch (type) {
                case 't2':
                    endpoint = `/api/patient/${patientId}/slice/${sliceIdx}/t2`;
                    break;
                case 'ff':
                    endpoint = `/api/patient/${patientId}/slice/${sliceIdx}/ff?cmap=${COLORMAP_VERSION}`;
                    break;
                case 'seg':
                    endpoint = `/api/patient/${patientId}/slice/${sliceIdx}/segmentation`;
                    break;
                case 'seg_eroded':
                    endpoint = `/api/patient/${patientId}/slice/${sliceIdx}/segmentation_eroded`;
                    break;
                case 'pred':
                    endpoint = `/api/patient/${patientId}/slice/${sliceIdx}/prediction?cmap=${COLORMAP_VERSION}&experiment=${encodeURIComponent(currentExperiment || '')}&ts=${predictionCacheBust}`;
                    break;
            }

            const url = `${API_BASE}${endpoint}`;

            return new Promise((resolve, reject) => {
                const img = new Image();
                // Set crossOrigin to allow reading pixel data from canvas
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    if (type === 'pred') {
                        console.log('[FRONTEND] Prediction image loaded successfully:', url, img.width, 'x', img.height);
                    }
                    imageCache[type][cacheKey] = img;
                    resolve(img);
                };
                img.onerror = (err) => {
                    if (type === 'pred') {
                        console.log('[FRONTEND] Prediction image failed to load:', url, err);
                    }
                    reject(err);
                };
                img.src = url;
            });
        }

        function preloadSlices(centerSlice) {
            const preloadRange = 5;

            for (let offset = -preloadRange; offset <= preloadRange; offset++) {
                const sliceIdx = centerSlice + offset;
                if (sliceIdx >= 0 && sliceIdx < numSlices) {
                    ['t2', 'ff', 'seg', 'pred'].forEach(type => {
                        loadImage(type, currentPatientId, sliceIdx);
                    });
                }
            }
        }

        async function preloadAllSlices(token) {
            // Preload all slices for the current patient in the background
            console.log(`[PRELOAD] Starting preload of all ${numSlices} slices for patient ${currentPatientId}`);

            const statusElement = document.getElementById('preloadStatus');
            statusElement.textContent = 'Loading...';

            let loadedCount = 0;
            const totalToLoad = numSlices * 3; // t2, ff, seg per slice

            for (let sliceIdx = 0; sliceIdx < numSlices; sliceIdx++) {
                if (token !== preloadToken) {
                    console.log('[PRELOAD] Cancelled preload (patient changed)');
                    statusElement.textContent = '';
                    return;
                }
                // Preload T2, FF, and segmentation (not prediction as it may not exist)
                const promises = ['t2', 'ff', 'seg'].map(type =>
                    loadImage(type, currentPatientId, sliceIdx)
                        .then(() => {
                            loadedCount++;
                            // Update status every 10% or so
                            if (loadedCount % Math.max(1, Math.floor(totalToLoad / 10)) === 0 || loadedCount === totalToLoad) {
                                const percent = Math.round((loadedCount / totalToLoad) * 100);
                                statusElement.textContent = `Preloading: ${percent}%`;
                            }
                        })
                        .catch(() => {
                            loadedCount++;
                            // Silently ignore errors for missing images
                        })
                );

                // Process in batches to avoid overwhelming the browser
                if (sliceIdx % 10 === 0) {
                    await Promise.all(promises);
                }
            }

            // Wait for any remaining promises
            await new Promise(resolve => setTimeout(resolve, 100));

            console.log(`[PRELOAD] Completed preload of ${loadedCount}/${totalToLoad} images`);
            statusElement.textContent = 'âœ“ All slices loaded';

            // Clear the status message after a few seconds
            setTimeout(() => {
                statusElement.textContent = '';
            }, 3000);
        }

        async function preloadAllHistograms(token) {
            if (!currentPatientId) return;

            const patientId = currentPatientId;
            const hasPred = predictionAvailable;
            const totalPerSlice = hasPred ? 2 : 1;
            const totalToLoad = numSlices * totalPerSlice;
            let loadedCount = 0;

            console.log(`[PRELOAD] Starting histogram preload of ${totalToLoad} items for patient ${patientId}`);

            for (let sliceIdx = 0; sliceIdx < numSlices; sliceIdx++) {
                if (token !== preloadToken) {
                    console.log('[PRELOAD] Cancelled histogram preload (patient changed)');
                    return;
                }
                const promises = [
                    loadHistogram('ff', patientId, sliceIdx)
                        .then(() => {
                            loadedCount++;
                        })
                        .catch(() => {
                            loadedCount++;
                        })
                ];

                if (hasPred) {
                    promises.push(
                        loadHistogram('pred', patientId, sliceIdx)
                            .then(() => {
                                loadedCount++;
                            })
                            .catch(() => {
                                loadedCount++;
                            })
                    );
                }

                if (sliceIdx % 10 === 0) {
                    await Promise.all(promises);
                }
            }

            await new Promise(resolve => setTimeout(resolve, 100));

            console.log(`[PRELOAD] Completed histogram preload of ${loadedCount}/${totalToLoad}`);
        }

        function toggleMask(type) {
            const checkbox = document.getElementById(`show${type.charAt(0).toUpperCase() + type.slice(1)}Mask`);
            maskVisible[type] = checkbox.checked;
            updateImages();
        }

        function togglePrediction() {
            const checkbox = document.getElementById('showPred');
            showPrediction = checkbox.checked;

            // If trying to show prediction but no prediction exists, uncheck and alert
            if (showPrediction) {
                if (!predictionAvailable) {
                    checkbox.checked = false;
                    showPrediction = false;
                    alert('No prediction available for this patient. Click "Run Prediction" to generate one.');
                    return;
                }
            }

            updateImages();
        }

        function drawHistogram(data, canvasId, statPrefix) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext("2d");
            const container = canvas.parentElement;

            // Get dimensions from parent container instead of canvas
            const dpr = window.devicePixelRatio || 1;
            const width = container.offsetWidth || 250;  // fallback to reasonable default
            const height = container.offsetHeight || 120;

            // Set canvas size
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);

            ctx.clearRect(0, 0, width, height);

            const { bins, counts, stats } = data;
            const maxCount = Math.max(...counts);
            if (maxCount === 0) return;  // Avoid division by zero

            const barWidth = width / counts.length;

            counts.forEach((count, i) => {
                const h = (count / maxCount) * height;
                const [r, g, b] = getCustomColor(i / counts.length);
                ctx.fillStyle = `rgb(${r},${g},${b})`;
                ctx.fillRect(i * barWidth, height - h, barWidth - 1, h);
            });

            // Update stats text
            document.getElementById(`histMin${statPrefix}`).textContent = stats.min.toFixed(1) + '%';
            document.getElementById(`histMax${statPrefix}`).textContent = stats.max.toFixed(1) + '%';
            document.getElementById(`histMean${statPrefix}`).textContent = stats.mean.toFixed(1) + '%';
            document.getElementById(`histMedian${statPrefix}`).textContent = stats.median.toFixed(1) + '%';
            document.getElementById(`histP25${statPrefix}`).textContent = stats.p25.toFixed(1) + '%';
            document.getElementById(`histP75${statPrefix}`).textContent = stats.p75.toFixed(1) + '%';
        }

        async function updateHistogram() {
            if (!currentPatientId) return;
            const patientId = currentPatientId;
            const sliceIdx = currentSlice;

            // Update ground truth FF histogram
            try {
                const data = await loadHistogram('ff', patientId, sliceIdx);
                if (data && data.counts && data.counts.length > 0) {
                    drawHistogram(data, 'histogramCanvas', '');
                }
            } catch (err) {
                console.warn('FF histogram fetch failed:', err);
            }

            // Update prediction histogram if prediction exists
            if (predictionAvailable) {
                try {
                    const data = await loadHistogram('pred', patientId, sliceIdx);
                    if (data && data.counts && data.counts.length > 0) {
                        drawHistogram(data, 'histogramCanvasPred', 'Pred');
                    } else {
                        clearHistogram('histogramCanvasPred', 'Pred');
                    }
                } catch (err) {
                    console.warn('Prediction histogram fetch failed:', err);
                    clearHistogram('histogramCanvasPred', 'Pred');
                }
            } else {
                // Clear prediction histogram if no prediction available
                clearHistogram('histogramCanvasPred', 'Pred');
            }
        }

        function clearHistogram(canvasId, statPrefix) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const container = canvas.parentElement;

            // Reset canvas size properly
            const dpr = window.devicePixelRatio || 1;
            const width = container.offsetWidth || 250;
            const height = container.offsetHeight || 120;

            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
            ctx.clearRect(0, 0, width, height);

            // Clear stats
            document.getElementById(`histMin${statPrefix}`).textContent = '-';
            document.getElementById(`histMax${statPrefix}`).textContent = '-';
            document.getElementById(`histMean${statPrefix}`).textContent = '-';
            document.getElementById(`histMedian${statPrefix}`).textContent = '-';
            document.getElementById(`histP25${statPrefix}`).textContent = '-';
            document.getElementById(`histP75${statPrefix}`).textContent = '-';
        }

        async function loadHistogram(type, patientId, sliceIdx) {
            const cacheKey = type === 'pred'
                ? `${patientId}_${sliceIdx}_${currentExperiment || 'default'}`
                : `${patientId}_${sliceIdx}`;
            if (histogramCache[type][cacheKey]) {
                return histogramCache[type][cacheKey];
            }

            let endpoint;
            switch (type) {
                case 'ff':
                    endpoint = `/api/patient/${patientId}/slice/${sliceIdx}/ff_histogram`;
                    break;
                case 'pred':
                    endpoint = `/api/patient/${patientId}/slice/${sliceIdx}/prediction_histogram?experiment=${encodeURIComponent(currentExperiment || '')}`;
                    break;
                default:
                    return null;
            }

            const response = await fetch(`${API_BASE}${endpoint}`);
            if (!response.ok) {
                return null;
            }
            const data = await response.json();
            histogramCache[type][cacheKey] = data;
            return data;
        }
        async function generatePrediction() {
            if (!currentPatientId) {
                alert('Please load a patient first');
                return;
            }

            currentExperiment = getSelectedExperiment();
            console.log('Starting prediction for patient:', currentPatientId);
            document.getElementById('generatePredictionBtn').disabled = true;
            document.getElementById('generatePredictionBtn').textContent = 'Queued...';

            try {
                const resp = await fetch(`${API_BASE}/api/prediction/generate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ patient_id: currentPatientId, experiment: currentExperiment })
                });

                const data = await resp.json();
                console.log('Prediction response:', data);

                if (!resp.ok) {
                    alert('Prediction request failed: ' + (data.error || resp.status));
                    document.getElementById('generatePredictionBtn').disabled = false;
                    updatePredictionButtonLabel();
                    return;
                }

                // Start polling for status
                const experimentName = data.experiment || currentExperiment;
                pollPredictionStatus(currentPatientId, experimentName);
            } catch (err) {
                console.error('Prediction request error:', err);
                alert('Prediction request error: ' + err);
                document.getElementById('generatePredictionBtn').disabled = false;
                updatePredictionButtonLabel();
            }
        }

        function pollPredictionStatus(patientId, experiment) {
            if (predictionPolling) clearInterval(predictionPolling);
            predictionPolling = setInterval(async () => {
                try {
                    const resp = await fetch(`${API_BASE}/api/prediction/status?patient_id=${patientId}&experiment=${encodeURIComponent(experiment || '')}`);
                    const data = await resp.json();
                    const jobKey = `${patientId}:${experiment}`;
                    const job = data.jobs && data.jobs[jobKey];

                    if (!job) return;

                    if (job.status === 'running' || job.status === 'queued') {
                        document.getElementById('generatePredictionBtn').textContent = 'Running...';
                    } else if (job.status === 'completed') {
                        clearInterval(predictionPolling);
                        predictionPolling = null;
                        document.getElementById('generatePredictionBtn').disabled = false;
                        updatePredictionButtonLabel();

                        // Clear prediction cache to force reload
                        imageCache.pred = {};

                        // Enable prediction checkbox and check it
                        await refreshPredictionAvailability();

                        // Refresh patient data and images
                        await loadPatientData(currentPatientId);
                        updateImages();
                        updateHistogram();
                        alert('Prediction completed!');
                    } else if (job.status === 'error') {
                        clearInterval(predictionPolling);
                        predictionPolling = null;
                        document.getElementById('generatePredictionBtn').disabled = false;
                        updatePredictionButtonLabel();
                        alert('Prediction failed: ' + (job.error || 'unknown'));
                    }
                } catch (err) {
                    console.error('Polling error', err);
                }
            }, 2000);
        }

        async function loadPatientData(patientId) {
            try {
                const resp = await fetch(`${API_BASE}/api/patient/${patientId}/info`);
                if (!resp.ok) return;
                const data = await resp.json();

                // Update in allPatientsData
                const idx = allPatientsData.findIndex(p => p.patient_id === patientId);
                if (idx >= 0) allPatientsData[idx] = data;

                // Update in patientsData (filtered list) if present
                const jdx = patientsData.findIndex(p => p.patient_id === patientId);
                if (jdx >= 0) patientsData[jdx] = data;

                // If this patient is currently loaded, update slice count and reload images
                if (currentPatientId === patientId) {
                    numSlices = data.num_slices;
                    document.getElementById('sliceSlider').max = numSlices - 1;
                }
                if (currentPatientId === patientId) {
                    await refreshPredictionAvailability();
                }
            } catch (err) {
                console.error('Error loading patient info', err);
            }
        }

        function showError(elementId, message) {
            const errorElement = document.getElementById(elementId);
            errorElement.textContent = message;
            errorElement.style.display = 'block';
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (!currentPatientId) return;

            if (e.key === 'ArrowLeft' && currentSlice > 0) {
                currentSlice--;
                document.getElementById('sliceSlider').value = currentSlice;
                onSliceChange();
            } else if (e.key === 'ArrowRight' && currentSlice < numSlices - 1) {
                currentSlice++;
                document.getElementById('sliceSlider').value = currentSlice;
                onSliceChange();
            }
        });
    </script>
</body>
</html>
